/*
 * lcd.c
 *
 * Created: 11/10/2014 4:34:52 PM
 *  Author: Jonathon
 */

#include "spi.h"
#include "lcd.h"
//#include "font57.c"
const  uint8_t font[] PROGMEM  =
{
	0x00, 0x00, 0x00, 0x00, 0x00, // SPACE
	0x00, 0x00, 0x5F, 0x00, 0x00, // !
	0x00, 0x03, 0x00, 0x03, 0x00, // "
	0x14, 0x3E, 0x14, 0x3E, 0x14, // #
	0x24, 0x2A, 0x7F, 0x2A, 0x12, // $
	0x43, 0x33, 0x08, 0x66, 0x61, // %
	0x36, 0x49, 0x55, 0x22, 0x50, // &
	0x00, 0x05, 0x03, 0x00, 0x00, // '
	0x00, 0x1C, 0x22, 0x41, 0x00, // (
	0x00, 0x41, 0x22, 0x1C, 0x00, // )
	0x14, 0x08, 0x3E, 0x08, 0x14, // *
	0x08, 0x08, 0x3E, 0x08, 0x08, // +
	0x00, 0x50, 0x30, 0x00, 0x00, // ,
	0x08, 0x08, 0x08, 0x08, 0x08, // -
	0x00, 0x60, 0x60, 0x00, 0x00, // .
	0x20, 0x10, 0x08, 0x04, 0x02, // /
	0x3E, 0x51, 0x49, 0x45, 0x3E, // 0
	0x04, 0x02, 0x7F, 0x00, 0x00, // 1
	0x42, 0x61, 0x51, 0x49, 0x46, // 2
	0x22, 0x41, 0x49, 0x49, 0x36, // 3
	0x18, 0x14, 0x12, 0x7F, 0x10, // 4
	0x27, 0x45, 0x45, 0x45, 0x39, // 5
	0x3E, 0x49, 0x49, 0x49, 0x32, // 6
	0x01, 0x01, 0x71, 0x09, 0x07, // 7
	0x36, 0x49, 0x49, 0x49, 0x36, // 8
	0x26, 0x49, 0x49, 0x49, 0x3E, // 9
	0x00, 0x36, 0x36, 0x00, 0x00, // :
	0x00, 0x56, 0x36, 0x00, 0x00, // ;
	0x08, 0x14, 0x22, 0x41, 0x00, // <
	0x14, 0x14, 0x14, 0x14, 0x14, // =
	0x00, 0x41, 0x22, 0x14, 0x08, // >
	0x02, 0x01, 0x51, 0x09, 0x06, // ?
	0x3E, 0x41, 0x59, 0x55, 0x5E, // @
	0x7E, 0x09, 0x09, 0x09, 0x7E, // A
	0x7F, 0x49, 0x49, 0x49, 0x36, // B
	0x3E, 0x41, 0x41, 0x41, 0x22, // C
	0x7F, 0x41, 0x41, 0x41, 0x3E, // D
	0x7F, 0x49, 0x49, 0x49, 0x41, // E
	0x7F, 0x09, 0x09, 0x09, 0x01, // F
	0x3E, 0x41, 0x41, 0x49, 0x3A, // G
	0x7F, 0x08, 0x08, 0x08, 0x7F, // H
	0x00, 0x41, 0x7F, 0x41, 0x00, // I
	0x30, 0x40, 0x40, 0x40, 0x3F, // J
	0x7F, 0x08, 0x14, 0x22, 0x41, // K
	0x7F, 0x40, 0x40, 0x40, 0x40, // L
	0x7F, 0x02, 0x0C, 0x02, 0x7F, // M
	0x7F, 0x02, 0x04, 0x08, 0x7F, // N
	0x3E, 0x41, 0x41, 0x41, 0x3E, // O
	0x7F, 0x09, 0x09, 0x09, 0x06, // P
	0x1E, 0x21, 0x21, 0x21, 0x5E, // Q
	0x7F, 0x09, 0x09, 0x09, 0x76, //R
	0x26, 0x49, 0x49, 0x49, 0x32, // S
	0x01, 0x01, 0x7F, 0x01, 0x01, // T
	0x3F, 0x40, 0x40, 0x40, 0x3F, // U
	0x1F, 0x20, 0x40, 0x20, 0x1F, // V
	0x7F, 0x20, 0x10, 0x20, 0x7F, // W
	0x41, 0x22, 0x1C, 0x22, 0x41, // X
	0x07, 0x08, 0x70, 0x08, 0x07, // Y
	0x61, 0x51, 0x49, 0x45, 0x43, // Z
	0x00, 0x7F, 0x41, 0x00, 0x00, // [
	0x02, 0x04, 0x08, 0x10, 0x20, // 
	0x00, 0x00, 0x41, 0x7F, 0x00, // ]
	0x04, 0x02, 0x01, 0x02, 0x04, // ^
	0x40, 0x40, 0x40, 0x40, 0x40, // _
	0x00, 0x01, 0x02, 0x04, 0x00, // `
	0x20, 0x54, 0x54, 0x54, 0x78, // a
	0x7F, 0x44, 0x44, 0x44, 0x38, // b
	0x38, 0x44, 0x44, 0x44, 0x44, // c
	0x38, 0x44, 0x44, 0x44, 0x7F, // d
	0x38, 0x54, 0x54, 0x54, 0x18, // e
	0x04, 0x04, 0x7E, 0x05, 0x05, // f
	0x08, 0x54, 0x54, 0x54, 0x3C, // g
	0x7F, 0x08, 0x04, 0x04, 0x78, // h
	0x00, 0x44, 0x7D, 0x40, 0x00, // i
	0x20, 0x40, 0x44, 0x3D, 0x00, // j
	0x7F, 0x10, 0x28, 0x44, 0x00, // k
	0x00, 0x41, 0x7F, 0x40, 0x00, // l
	0x7C, 0x04, 0x78, 0x04, 0x78, // m
	0x7C, 0x08, 0x04, 0x04, 0x78, // n
	0x38, 0x44, 0x44, 0x44, 0x38, // o
	0x7C, 0x14, 0x14, 0x14, 0x08, // p
	0x08, 0x14, 0x14, 0x14, 0x7C, // q
	0x00, 0x7C, 0x08, 0x04, 0x04, // r
	0x48, 0x54, 0x54, 0x54, 0x20, // s
	0x04, 0x04, 0x3F, 0x44, 0x44, // t
	0x3C, 0x40, 0x40, 0x20, 0x7C, // u
	0x1C, 0x20, 0x40, 0x20, 0x1C, // v
	0x3C, 0x40, 0x30, 0x40, 0x3C, // w
	0x44, 0x28, 0x10, 0x28, 0x44, // x
	0x0C, 0x50, 0x50, 0x50, 0x3C, // y
	0x44, 0x64, 0x54, 0x4C, 0x44, // z
	0x00, 0x08, 0x36, 0x41, 0x41, // {
		0x00, 0x00, 0x7F, 0x00, 0x00, // |
	0x41, 0x41, 0x36, 0x08, 0x00, // }
0x02, 0x01, 0x02, 0x04, 0x02};// ~



//const extern uint8_t PROGMEM font[];

byte LCD_data_tx(byte tx_byte) //Sends  a data byte
{
	LCD_CHIP_SELECT;
	LCD_DATA_SET_HIGH;
	spi_tx(tx_byte);
	LCD_CHIP_DESELECT;
	return(TRUE);
}

byte LCD_command_tx(byte tx_byte) //Sends  a data byte as command
{
	LCD_CHIP_SELECT;
	LCD_DATA_SET_LOW;
	spi_tx(tx_byte);
	LCD_CHIP_DESELECT;
	return(TRUE);
}

byte select_page (byte page) { //selects page to be written to 
	byte page_cmd_address;
	if(page > MAX_PAGES) {
		page = MAX_PAGES-1;
	}
	page_cmd_address =(CMD_PAGE | page);
	LCD_command_tx(page_cmd_address );
	return(TRUE);
}

byte select_column (byte column) { //selects column to be written to
	byte page_cmd_address_MSB;
	byte page_cmd_address_LSB;
	if(column > MAX_COLUMNS) {
		column = MAX_COLUMNS-1;
	}
	page_cmd_address_LSB =(CMD_COL_LSB | (column & 0x0F));
	page_cmd_address_MSB =(CMD_COL_MSB | (column >> 4));
	LCD_command_tx(page_cmd_address_LSB);
	LCD_command_tx(page_cmd_address_MSB);
	return(TRUE);
}

byte init_lcd(void) { // initialize lcd, must be run prior to using lcd
	// BACKLIGHT
	BACKLIGHT_SET(OFF);
	BACKLIGHT_DIR(OUT);
	SET_UP_TIMER_REG();
	PRESCALER_8();
	BACKLIGHT_BRIGHTNESS(0);
	
	//LCD
	LCD_CHIP_SELECT_DIR(OUT);
	LCD_DATA_SET_DIR(OUT);
	LCD_RST_SET_DIR(OUT);
	LCD_RST_SET_HIGH;
	_delay_ms(100);
	LCD_command_tx(0xE2);//reset
	LCD_command_tx(0x40);//Display start line 0
	LCD_command_tx(0xA1);//SEG reverse
	LCD_command_tx(0xC0);//Normal COM0~COM63
	LCD_command_tx(0xA4);//Disable -> Set All Pixel to ON
	LCD_command_tx(0xA6);//Display inverse off
	_delay_ms(120);
	LCD_command_tx(0xA2);//Set LCD Bias Ratio A2/A3
	LCD_command_tx(0x2F);//Set Power Control 28...2F
	LCD_command_tx(0x27);//Set VLCD Resistor Ratio 20...27
	LCD_command_tx(0x81);//Set Electronic Volume
	LCD_command_tx(0x10);//Set Electronic Volume 00...3F
	LCD_command_tx(0xFA);//Set Adv. Program Control
	LCD_command_tx(0x90);//Set Adv. Program Control x00100yz yzcolumn wrap x Temp Comp
	LCD_command_tx(0xAF);//Display on
	set_all_lcd_pages(OFF);
	return(TRUE);
}

byte set_all_lcd_pages(byte val) {  //sets all pages to val
	for(int page=0;page<MAX_PAGES; page++) {
		for(int column = 0; column<MAX_COLUMNS; column++)	{
			select_page(page);
			select_column(column);
			LCD_data_tx(val);
		}
	}
	return(TRUE);
}

/* Everything Below is adapted from
from https://github.com/adafruit/ST7565-LCD */
  
void write_buffer(byte buff[][MAX_PAGES]) {

  byte c, p;
  
  for(p = 0; p < MAX_PAGES; p++) {

    select_page(p);
	select_column(0x00);    
    for(c = 0; c < MAX_COLUMNS; c++) {
	  select_column(c);
      LCD_data_tx(buff[c][p]);
    }
  }
}

void setpixel(byte buff[][MAX_PAGES], byte x, byte y) {
	if ((x >= LCDWIDTH) || (y >= LCDHEIGHT))
	return;

	// x is which column
	byte page = y/8;
	byte pixel = y%8;
	pixel = (_BV(pixel) | (buff[x][page])); 
	
	select_page(page);
	select_column(x);
	buff[x][page] |= pixel;
	LCD_data_tx(pixel);
}

void clearpixel(byte buff[][MAX_PAGES], byte x, byte y) {
	if ((x >= LCDWIDTH) || (y >= LCDHEIGHT))
	return;

	// x is which column
	byte page = y/8;
	byte pixel = y%8;
	pixel = ((~_BV(pixel) & 0xff) & (buff[x][page]));
	
	select_page(page);
	select_column(x);
	buff[x][page] &= pixel;
	LCD_data_tx(pixel);
}

void drawline(byte buff[][MAX_PAGES],byte x0, byte y0, byte x1, byte y1) {

	uint8_t steep = abs(y1 - y0) > abs(x1 - x0);
	if (steep) {
		swap(x0, y0);
		swap(x1, y1);
	}

	if (x0 > x1) {
		swap(x0, x1);
		swap(y0, y1);
	}

	uint8_t dx, dy;
	dx = x1 - x0;
	dy = abs(y1 - y0);

	int8_t err = dx / 2;
	int8_t ystep;

	if (y0 < y1) {
		ystep = 1;
		} else {
	ystep = -1;}

	for (; x0<x1; x0++) {
		if (steep) {
			setpixel(buff, y0, x0);
			} else {
			setpixel(buff, x0, y0);
		}
		err -= dy;
		if (err < 0) {
			y0 += ystep;
			err += dx;
		}
	}
}

void drawchar(byte buff[][MAX_PAGES], byte x, byte line, byte c) {
	for (uint8_t i =0; i<5; i++ ) {
		//byte address = font[(c*5)+i];
		int temp = 5*(c-0x20);
		int address = font+temp+i;
		byte ascii = pgm_read_byte(address);
		buff[x][line] = ascii;
		select_page(line);
		select_column(x);
		LCD_data_tx(ascii);
		x++;
	}
}

void drawstring(byte buff[][MAX_PAGES], byte x, byte line, byte *c) {
	while (c[0] != 0) {
		//uart_putchar(c[0]);
		drawchar(buff, x, line, *c);
		c++;
		x += 6; // 6 pixels wide
		if (x + 6 >= LCDWIDTH) {
			x = 0;    // ran out of this line
			line++;
		}
		if (line >= MAX_PAGES)
		return;        // ran out of space :(
	}

}